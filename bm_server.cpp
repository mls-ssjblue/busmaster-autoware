
/* This file is generated by BUSMASTER */
/* VERSION [1.2] */
/* BUSMASTER VERSION [2.6.4] */
/* PROTOCOL [CAN] */

/* Start BUSMASTER include header */
//#include <Windows.h>
#include <CANIncludes.h>
#include <inttypes.h>
#include <ctime>
#include <iostream>
#include <stdio.h>
//#include <winsock.h>
#include <winsock2.h>
#include <math.h>
#include <float.h>

using namespace std;
#define PORT 8085
#define M_PI 3.14

//#pragma comment(lib, "ws2_32.lib") //Winsock Library
/* End BUSMASTER include header */

/* Start BUSMASTER global variable */
float i = 0;
time_t t;
/* End BUSMASTER global variable */
static int j = 0;
int recv_count = 0;
int* client_sock;
SOCKET client_socket_final;
/* Start BUSMASTER Function Prototype  */
GCC_EXTERN void GCC_EXPORT OnTimer_timer_100ms_100();
GCC_EXTERN void GCC_EXPORT OnMsgID_101(STCAN_MSG RxMsg);
/* End BUSMASTER Function Prototype  */

/* Start BUSMASTER Function Wrapper Prototype  */
/* End BUSMASTER Function Wrapper Prototype  */

/* Start BUSMASTER Function Wrapper Prototype  */
/* End BUSMASTER Function Wrapper Prototype  */
float m_lat,m_lon, m_h;
/*double compute(double *recv_array)
{
  double latd = recv_array[0];
  double lond = recv_array[1];
  double h = recv_array[2];
  double lat, lad, lod, lon, m_lat, m_lon, m_h;

  lad = floor(latd / 100.);
  lat = latd - lad * 100.;
  lod = floor(lond / 100.);
  lon = lond - lod * 100.;
  // Changing Longitude and Latitude to Radians
  m_lat = (lad + lat / 60.0) * M_PI / 180;
  m_lon = (lod + lon / 60.0) * M_PI / 180;
  m_h = h;
  //return all three values
}*/
uint32_t htonf(float f)
{
  uint32_t p;
  uint32_t sign;

  if (f < 0) { sign = 1; f = -f; }
  else { sign = 0; }
    
  p = ((((uint32_t)f)&0x7fff)<<16) | (sign<<31); // whole part and sign
  p |= (uint32_t)(((f - (int)f) * 65536.0f))&0xffff; // fraction

  return p;
}

float ntohf(uint32_t p)
{
  float f = ((p>>16)&0x7fff); // whole part
  f += (p&0xffff) / 65536.0f; // fraction

  if (((p>>31)&0x1) == 0x1) { f = -f; } // sign bit set

  return f;
}
void *testCalculate(void *arg)
{
  
  cout << "in test calculate";
  Trace("in test calculate ");
  int sock = *((int *) arg);
  Trace("sock = %d",sock);
  Trace("client_socket_final = %d",client_socket_final);
   float recv_array[3];
  int i = 0;
  //Receive array of arguments one by one over TCP socket
  long recv_data[3];
  int recv_size;
  uint32_t arr_size = 0;
  int bufLen = 50;
  Trace("\n Calling recv to receive data ");
  int iResult = recv(sock, (char*)recv_data, sizeof(recv_data), 0);
  if (iResult > 0)
  {
    Trace("Bytes received: %d \n", iResult);
  }
  else if (iResult == 0)
  {
    Trace("Connection closed\n");
  }
  else
    Trace("recv failed:%d \n", WSAGetLastError());
  for(int i =0;i<3;i++){
  recv_array[i] = (float)ntohf(recv_data[i]);
  }

  Trace("\nDeserialized data is %f %f %f", recv_array[0], recv_array[1], recv_array[2]);
  Trace("\nDeserialized data is %f", recv_array);
  std::clock_t c_start = std::clock();
  STCAN_MSG sMsgStruct;
  sMsgStruct.id = 0x100;
  sMsgStruct.dlc = 12;
  sMsgStruct.cluster = 1;
  sMsgStruct.data[0] =  (float)recv_array[0];
  sMsgStruct.data[1] =  (float)recv_array[1];
  sMsgStruct.data[2] =  (float)recv_array[2];
  //i += 2;
  memcpy(&sMsgStruct.data, &recv_array[0], sizeof(float));
  Trace("1. sending first val to bmnode1");
  SendMsg(sMsgStruct);

  memcpy(&sMsgStruct.data, &recv_array[1], sizeof(float));
  Trace("1. sending second val to bmnode1");
  SendMsg(sMsgStruct);
  memcpy(&sMsgStruct.data, &recv_array[2], sizeof(float));
  Trace("1. sending third val to bmnode1");
  SendMsg(sMsgStruct);

  return NULL;
}

void *networkThread(void *arg)
{
  WSADATA wsa;
  SOCKET master, new_socket, client_socket[30], s;
  struct sockaddr_in server, address;
  int max_clients = 30, activity, addrlen, i, valread;
  char *message = "ECHO Daemon v1.0 \r\n";
  //size of our receive buffer, this is string length.
  int MAXRECV = 1024;
  //set of socket descriptors
  fd_set readfds;
  //1 extra for null character, string termination
  char *buffer;
  buffer = (char *)malloc((MAXRECV + 1) * sizeof(char));
  for (i = 0; i < 30; i++)
  {
    client_socket[i] = 0;
  }
  Trace("\nInitialising Winsock...");
  if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
  {
    printf("Failed. Error Code : %d", WSAGetLastError());
    exit(EXIT_FAILURE);
  }
  Trace("Initialised.\n");
  //Create a socket
  if ((master = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET)
  {
    printf("Could not create socket : %d", WSAGetLastError());
    exit(EXIT_FAILURE);
  }
  Trace("Socket created.\n");
  server.sin_addr.s_addr = INADDR_ANY;
  server.sin_family = AF_INET;
  server.sin_port = htons(PORT);
  if (bind(master, (struct sockaddr *)&server, sizeof(server)) == SOCKET_ERROR)
  {
    printf("Bind failed with error code : %d", WSAGetLastError());
  }
  listen(master, 100000);
  Trace("\n Waiting for incoming connections");
  addrlen = sizeof(struct sockaddr_in);
  while (true)
  {
    //Wait for connection to autoware client
    Trace("\nWaiting access");
    client_socket_final = accept(master, (struct sockaddr *)&address, (int *)&addrlen);
    if (client_socket_final == -1)
    {
      Trace("accept error");
      break;
    }
    Trace("\nNew connection , socket fd is %d , ip is : %s , port : %d \n", client_socket_final, inet_ntoa(address.sin_addr), ntohs(address.sin_port));
    //Connected to autoware client
    Trace("Connected to Autoware client");
    int x;
    pthread_t th2;
    if (pthread_create(&th2, NULL, testCalculate, &client_socket_final) != 0)
    {
      cout << "pthread create error";
      break;
    }

    int ret = pthread_detach(th2);
    if (ret != 0)
    {
      Trace("pthread_detach error");
      break;
    }
    Trace("end ..");
  }
  Trace("Close master socket");
  closesocket(master);
  WSACleanup();
  return NULL;
}
/* Start BUSMASTER generated function - OnTimer_timer_100ms_100 *//////
void OnTimer_timer_100ms_100()
{
  std::clock_t c_start = std::clock();
  if (j == 0)
  {
    Trace("Socket error = %d",SOCKET_ERROR);
    client_sock = new int();
    Trace("Spinning a thread ...");
    pthread_t th;
    if (pthread_create(&th, NULL, networkThread, NULL) != 0)
    {
      Trace("pthread create error");
    }
    int ret = pthread_detach(th);
    if (ret != 0)
    {
      Trace("detach error");
    }
  }
  j++;
}


 /* End BUSMASTER generated function - OnTimer_timer_100ms_100 */
/* Start BUSMASTER generated function - OnMsgID_101 */
void OnMsgID_101(STCAN_MSG RxMsg)
{
   recv_count++;
  float recv_val = 0.0;
  memcpy(&recv_val,RxMsg.data,sizeof(float));
  Trace("Received result from bmnode1 = %f",recv_val);
  if(recv_count == 1)
     m_lat = recv_val;
  else if(recv_count == 2)
    m_lon = recv_val;
  else if(recv_count == 3){
    recv_count = 0;
    m_h = recv_val;
    Trace("Sending results back to Autoware");
    uint32_t data_converted[3];
    data_converted[0] = htonf(m_lat);
    data_converted[1] = htonf(m_lon);
    data_converted[2] = htonf(m_h);
    Trace("client sock is %d",client_socket_final);
    if( send(client_socket_final, (char*)data_converted, sizeof(data_converted), 0) == SOCKET_ERROR) 
    {
        Trace("send failed");
    }
    else
      Trace("Data sent to AW \n");
    closesocket(client_socket_final);
 }
}/* End BUSMASTER generated function - OnMsgID_101 */
